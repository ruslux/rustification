# Руководство Rust #

## 2 Hello, World! ##
Теперь, когда вы установили Rust, напишем первую вашу программу на Rust. Это традиция, в любом новом языке программирования, делать первую программу такой, которая выводит текст "Hello, World!" на экран. Хорошая штука начинать с такой простой программы в том, что вы можете убедиться что ваш компилятор не только установлен, но и работает правильно. И вывод информации на экран является довольно обычным способом для этого.

Первое с чего мы должны начать это создать файл для нашего кода. Мне нравится размещать каталог `projects` в домашнем каталоге, и хранить все мои проекты там. Для Rust неважно где располагается ваш код.

Это на самом деле приводит к еще одной проблеме о которой мы должны предупредить: это руководство предполагает, что у вас есть базовые навыки работы в командной строке. Rust не требует от вас великих познаний о командной строке, но до тех пор пока язык не будет в более завершенном виде, поддержка IDE затруднительна. У Rust нет специфичных требований к вашей среде разработки или к тому где вы храните свой код.

С учетом сказанного, давайте сделаем каталог в нашем каталоге с проектами.

    $ mkdir ~/projects
    $ cd ~/projects
    $ mkdir hello_world
    $ cd hello_world

Если вы используете Windows и не используете PowerShell, `~` может не работать. Обратитесь к документации вашей оболочки для уточнения деталей.

Теперь создадим новый файл для текста программы. Я собираюсь использовать синтаксис `editor filename` для обозначения редактируемого файла в этих примерах, но вам следует использовать любой метод, который хотите. Назовем наш файл `main.rs`:

`$ editor main.rs`

Rust файлы всегда заканчиваются расширением `.rs`. Если вы используете больше одного слова в имени вашего файла используйте подчеркивание. `hello_world.rs` лучше чем `helloworld.rs`.

Теперь когда файл открыт, запишите в него:

    fn main() {
        println!("Hello, world!");
    }

Сохраните файл и затем введите в вашем окне терминала:

    $ rustc main.rs
    $ ./main # или main.exe в Windows
    Hello, world!

Успех! Разберем что же случилось подробнее.

    fn main() {

    }

Эти строки определяют **функцию** в Rust'е. Функция `main` специальна: это начало каждой программы на Rust. Первая строка говорит "Я объявляю функцию именуемую `main`, которая не получает параметров и ничего не возвращает". Если бы были параметры, они бы шли в скобках (`(` и `)`), и потому что мы ничего не возвращаем из этой функции, мы опустим эту запись полностью. Мы вернемся к этому позже.

Вы должны были заметить, что функция обернута в фигурные скобки (`{` и `}`). Rust требует их вокруг всех тел функций. Так же хорошим стилем считается ставить открывающую фигурную скобку на той же строке, что и объявление функции, отделенную одним пробелом.

Теперь эта строка:

	println!("Hello, world!");

Эта строка делает всю работу в нашей маленькой программе. Тут есть несколько деталей, которые имеют существенное значение. Во-первых, отступ в четыре пробела, а не табуляция. Пожалуйста, настройте выбранный вами редактор так, чтобы вставлять четыре пробела при помощи клавиши табуляции. Мы предоставляем некоторые [примеры настроек для различных редакторов](https://github.com/rust-lang/rust/tree/master/src/etc "Примеры настроек для различных редакторов").

Во-вторых, это часть с `println!()`. Это вызов макроса Rust, которым представлено метапрограммирование в Rust'e. Если бы вместо этого была функция, это бы выглядело следующим образом: `println()`. Для достижения нашей цели, нас не должна волновать эта разница. Просто знайте, что иногда вы будете видеть `!`, и это означает, что вы вызываете макрос вместо нормальной функции. Rust реализует `println!` как макрос вместо функции по веским причинам, но это очень углубленная тема. Вы узнаете больше, когда мы будем позже рассказывать о макросах. И последнее, что нужно отметить: макросы Rust'a значительно отличаются от макросов на C, если вы их использовали. Не бойтесь использовать макросы. В конце концов мы вернемся к деталям, а сейчас просто доверьтесь нам.

Дальше, `"Hello, world!"` это **строка**. Строки удивительно сложная тема в системном языке программирования и это statically allocated строка. Мы расскажем больше о различных видах распределения памяти позже. Передадим эту строку в качестве аргумента в `println!`, который выводит строки на экран. Это достаточно просто!

В завершение, строка заканчивается точкой с запятой(`;`). Rust `выражение-ориентированный` язык, что означает, что в нем большая часть вещей является выражением. `;` используется для указания, что это выражение заканчивается, а следующее начинается. Большинство строк кода на Rust заканчивается `;`. Мы рассмотрим это позже в отдельном разделе руководства.

На самом деле, завершением будет сборка и запуск нашей программы. Соберем нашим компилятором `rustc`, передав ему в качестве аргумента название нашего файла с кодом:

    $ rustc main.rs

Это похоже на `gcc` или `clang`, если вы программировали раньше на C или C++. Rust выдаст двоичный исполняемый файл. Вы можете убедиться в этом с помощью `ls`:

    $ ls
    main main.rs

Или в Windows:

    $ dir
    main.exe main.rs

Это два файла: наш исходный код, с расширением `.rs` и исполняемый файл (`main.exe` в Windows, `main` в остальных случаях)

    $ ./main  # или main.exe в Windows

Это выведет наш "Hello, world!" текст в наш терминал.

Если вы перешли из динамически-типизированных языков программирования вроде Ruby, Python или JavaScript, вы не можете использовать эти два шага отдельно. Rust **компилируемый перед исполнением** язык, это означает, что вы можете собрать программу, дать ее кому-то еще, и ему не нужно устанавливать Rust. Если вы передадите один из `.rb` или `.py` или `.js` файл, ему нужно будет установить Ruby/Python/JavaScript, но запустить только одну команду для каждого из них, что бы скомпилировать и запустить вашу программу. Все это взаимоисключаемо в дизайне языков программирования, и Rust сделал свой выбор.

Поздравляем! Вы официально написали программу на Rust. Это делает вас Rust-программистом! Добро пожаловать.


## 3 Hello, Cargo! ##
[Cargo](http://doc.crates.io "Cargo site") это инструмент который Ржавообразные используют для управления своими Rust проектами. Cargo сейчас в состоянии альфы, как и Rust, и работа над ним еще продолжается. Тем не менее, он уже достаточно хорош для использования во многих Rust проектах, и поэтому предполагается, что проекты на Rust будут использовать Cargo с самого начала.

Cargo управляет тремя вещами: собирает ваш код, скачивает нужные вашему коду зависимости и собирает их. По-началу, вашей программе не понадобятся никаких зависимостей, поэтому будем использовать только первую часть его функционала. В конце концов нам понадобится добавить несколько зависимостей. Поскольку мы начали с использованием Cargo, не составит труда добавить их позже.

Преобразуем наш Hello World в Cargo. Первая вещь, которую мы должны сделать для того, что бы начать использовать Cargo - это установить его. К счастью для нас, скрипт который мы запускали для установки Rust по умолчанию включает в себя установку Cargo. Если вы установили Rust каким-либо другим способом, вы должны проверить [Cargo README для специальных инструкций по установке](https://github.com/rust-lang/cargo#installing-cargo-from-nightlies "Инструкция по установке Cargo").

Чтобы Cargo-фицировать ваш проект, вы должны сделать две вещи: создать `Cargo.toml` конфигурационный файл, и поместить файл с исходным кодом в правильное место. Давайте сделаем эту часть первой:

    $ mkdir src
    $ mv main.rs src/main.rs

Cargo ожидает что ваши файлы с исходным кодом находятся в директории `src`. Это оставляет верхний уровень для других вещей, вроде README, файлов с текстом лицензии и других не относящихся к вашему коду. Cargo помогает нам сохранять наши проекты красивыми и аккуратными. Всему своё место и всё на своём месте.

Дальше, наш конфигурационный файл:

    $ editor Cargo.toml

Убедитесь, что имя правильное: вам нужна заглавная `C`!

Разместите это внутри:

    [package]

    name = "hello_world"
    version = "0.0.1"
    authors = [ "Ваше имя <you@example.com>" ]

    [[bin]]

    name = "hello_world"

Этот файл в формате [TOML](https://github.com/toml-lang/toml "Описание формата TOML"). Позволим ему самому объясниться с вами:
>TOML стремится быть минимальным форматом для конфигурационных файлов, который легко читается благодаря понятной семантике. TOML спроектирован для однозначного отображения в хэш-таблицу. TOML должен легко преобразовываться в структуры данных широкого спектра языков программирования.

TOML очень похож на INI, но с некоторыми дополнительными возможностями.

В любом случае, в этом файле есть две записи: `package` и `bin`. Первая сообщает Cargo метаданные вашего пакета. Вторая сообщает Cargo что мы заинтересованы в сборке исполняемого файла, а не библиотеки (хотя мы могли сделать и то и другое!), и как его следует назвать.

Как только мы с этим закончили, мы готовы к сборке! Попробуйте собрать:

    $ cargo build
        Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
    $ ./target/hello_world
    Hello, world!

Та-да! Мы собрали наш проект вызвав `cargo build`, и запустили его с помощью `./target/hello_world`. Нас этим не купить по сравнению с более простым использованием `rustc`, но подумаем о будущем: если бы в нашем проекте было больше одного файла мы бы должны были вызвать `rustc` для каждого и передать ему кучу параметров, что бы собрать их все вместе. С `Cargo` когда наш проект вырастет нам понадобится вызвать только команду `cargo build` и она должна будет работать правильно.

Так же вы должны были заметить что Cargo создал новый файл: `Cargo.lock`.

    [root]
    name = "hello_world"
    version = "0.0.1"

Этот файл используется Cargo для отслеживания зависимостей в вашем приложении. Прямо сейчас у нас нет ни одной, поэтому этот файл довольно пуст. Вам не нужно править этот файл самостоятельно, Cargo сам с ним разберется.

Так! Мы успешно собрали `hello_world` с помощью Cargo. Несмотря на то, что наша программа проста, мы использовали большую часть реальных инструментов, которые вы будете использовать в своем дальнейшем пути Rust программиста.

Теперь давайте отложим инструментарий и узнаем больше о самом языке Rust. Эти основы сослужат вам хорошую службу до конца вашего времени с Rust.

## 4 Связывание переменных ##
Первая вещь которую мы должны знать о "связывании переменных" - это выглядит примерно так:

    let x = 5i;

Во многих языках программирования это называется "переменная". Но связывание переменных Rust'а имеет пару трюков в рукаве. Rust имеет мощную особенность называемую 'шаблоном', который мы рассмотрим позже более детально, с левой стороны выражение `let` это полный шаблон, а не просто имя переменной. Это значит что мы можем делать вещи вроде этой:

    let (x, y) = (1i, 2i);

После завершения этого выражения `x` будет единицей, a `y` двойкой. Шаблоны правда мощны, но пока это все, что мы можем с ними сделать. Так что придержите это в уме, продвигаясь дальше.

В этом примере, кстати, `i` показывает что число является целым числом.

Rust статически типизированный язык программирования, что означает, что мы сперва мы должны указать наш тип. Так почему же наш первый пример скомпилировался? В Rust'е есть такая вещь, как "вывод типа". Если Rust может понять какой тип у чего-либо, то он не требует указывать его.

Тем не менее, мы можем указать желаемый тип. Он следует после двоеточия (`:`):

    let x: int = 5;

Если бы я попросил вас прочитать это вслух и по-порядку, вы бы сказали "`x` связан с типом `int` и значением `пять`"

По-умолчанию, связывание `неизменяемо`. Этот код не скомпилируется:

    let x = 5i;
    x = 10i;

Мы получим эту ошибку:

    error: re-assignment of immutable variable `x`
        x = 10i;
        ^~~~~~~

Если вы хотите что бы связывание было изменяемым, вы можете использовать `mut`:

    let mut x = 5i;
    x = 10i;

Может показаться, что нет ни одной причины делать связывание неизменяемым по-умолчанию, но вспомните, на чем в первую очередь сфокусирован Rust: на безопасности. Если вы случайно забыли указать `mut`, компилятор поймет это, и вы узнаете, что изменили то, что возможно не собирались менять. Если бы связывание по-умолчанию было бы изменяемым, в такой ситуации компилятор не смог бы вам помочь. Если вы намерены сделать изменение, решение очень простое: добавьте `mut`.

Есть и другие весомые аргументы, по-возможности, избегать изменяемых состояний, но они выходят за рамки этого руководства. В общем, зачастую вы можете избежать явных изменений, поэтому это предпочтительнее в Rust'е. Тем не менее, иногда изменение это то, что вам нужно, так что это не запрещено.

Вернемся к связыванию. При связывании переменных Rust'а есть еще одно отличие от других языков: связывание требует инициализации перед использованием. Если мы попробуем...

    let x;

...мы получим ошибку:

    src/main.rs:2:9: 2:10 error: cannot determine a type for this local variable: unconstrained type
    src/main.rs:2     let x;
                          ^
Хотя указание типа позволит собрать:

    let x: int;

Давайте проверим. Измените ваш `src/main.rs` файл, что бы он выглядел следующим образом:

    fn main() {
        let x: int;

        println!("Hello world!");
    }

Вы можете использовать `cargo build` в командной строке, что бы собрать его. Вы получите предупреждение, но "Hello, world!" будет выведено:

       Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
    src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default
    src/main.rs:2     let x: int;
                                 ^

Rust предупредит нас о том, что мы никогда не используем связанную переменную, но, так как мы не используем ее, никакого вреда и нарушения в этом нет.
Однако все изменится если мы попробуем использовать `x`. Сделаем это. Измените вашу программу так, что бы она выглядела следующим образом:

    fn main() {
        let x: int;

        println!("The value of x is: {}", x);
    }

И попробуйте собрать. Вы получите ошибку:

    $ cargo build
       Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
    src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
    src/main.rs:4     println!("The value of x is: {}", x);
                                                        ^
    note: in expansion of format_args!
    <std macros>:2:23: 2:77 note: expansion site
    <std macros>:1:1: 3:2 note: in expansion of println!
    src/main.rs:4:5: 4:42 note: expansion site
    error: aborting due to previous error
    Could not compile `hello_world`.

Rust не позволит нам использовать неинициализированную переменную. Далее, поговорим о том, что мы добавили в `println!`.

Если вы добавите две фигурные скобки (`{}`, иногда называемые "усами"...) в вашу печатаемую строку, Rust истолкует это как просьбу своего рода вставки значения. `Строковая вставка` это термин в информатике, который обозначает "вставить посреди строки". Мы добавили запятую, и затем `x`, что бы указать, что мы хотим вставить `x` в строку. Запятая используется для разделения параметров передаваемых нами в функции и макросы, если вы передаете больше одного.

Когда вы используете фигурные скобки, Rust попытается отобразить значение осмысленно, проверяя его тип. Если вы хотите указать формат более детально, тут есть [большое количество доступных параметров](http://doc.rust-lang.org/0.12.0/std/fmt/ "Способы форматирования строк"). На данный момент мы будем вставлять как есть: целые числа не очень сложны для печати.

## 5 If ##
`If` Rust'а не слишком сложный, но это больше похоже на `if` динамических языков программирования, чем на `if` более традиционных системных языков программирования. Итак, давайте поговорим об этом, что бы вы действительно поняли нюансы. `if` специальная форма более общей идеи, `ветка`. Название пошло от ветки дерева: точка принятия решения, в которой из множества путей может быть выбран один.

В случае с `if`, тут выбор одного из двух путей:

    let x = 5i;

    if x == 5i {
        println!("x is five!");
    }

Если мы изменим значение `x` на что-нибудь другое, эта строка не будет напечатана. В частности, если выражение после `if` истинно, то блок выполняется. Если оно ложно, то нет.

Если вы хотите чего-либо в случае с `false`, используйте `else`:

    let x = 5i;

    if x == 5i {
        println!("x is five!");
    } else {
        println!("x is not five :(");
    }

Это все довольно стандартно. Однако, вы также можете сделать вот так:

    let x = 5i;

    let y = if x == 5i {
        10i
    } else {
        15i
    };

Что мы можем (и вероятно должны) написать так:

    let x = 5i;

    let y = if x == 5i { 10i } else { 15i };

Это показывает две интересные вещи о Rust'е: это `выражение-ориентированный` язык программирования и точка с запятой играет немного другую роль, чем в других языках программирования с "фигурными скобками и точками с запятой" в основе. Эти две вещи связаны.


##5.1 Выражения vs. Операторы##
Rust в первую очередь язык программирования основанный на выражениях. Тут есть только два вида операторов, все остальное является выражениями.

Так в чем же разница? Выражение возвращает значение, а оператор - нет. Во многих языках программирования `if` это оператор, следовательно `let x = if ...` не имело бы смысла. Но в Rust'e `if` это выражение, которое в состоянии вернуть значение. Мы можем использовать это значение для инициализации при связывании. Кстати говоря, связывание это первый из двух видов операторов в Rust'е. Его более точное название это `оператор объявления`. Пока что `let` это единственный оператор объявления который мы видели. Давайте поговорим об этом еще немного.

В некоторых языках программирования, связывание переменных может быть записано не только в виде оператора, но и в виде выражения. Например, Ruby:

    x = y = 5

В Rust'е, однако, использование `let` для связывания переменных не является выражением. Следующее выдаст ошибку во время сборки:

    let x = (let y = 5i); // expected identifier, found keyword `let`

Тут компилятор нам скажет, что ожидает увидеть начало выражения, а `let` может начать только оператор, а не выражение.

Обратите внимание, что присваивание уже связанной переменной (например, `у = 5i`) является выражением, хотя его значение не особенно полезно. В отличие от C, присваивание приравнивается к присвоенному значению (например, `5i` в предыдущем примере), в Rust'е значение выражения присваивания это блочный (?) тип `()` (о котором мы расскажем позже).

Второй тип операторов в Rust'е это `оператор выражения`. Его цель это превращение (?) любого выражения в оператор. С практической точки зрения, грамматика Rust'а ожидает операторы последовательно, оператор за оператором. Это означает, что вы используете точку с запятой для отделения выражений друг от друга. Это значит, что Rust подобен большинству других языков программирования, которые требуют использовать точку с запятой в конце каждой строки, и вы увидите точку с запятой почти в каждой строке кода Rust.

Что за исключение, которое нас заставляет говорить "почти"? Ты уже видел это в этом коде:

    let x = 5i;

    let y: int = if x == 5i { 10i } else { 15i };

Обратите внимание, что я добавил тип для `у`, чтобы явно указать, что я хочу, чтобы `у` был целым числом.
Этот пример не то же самое, что нижеприведенный, который не соберется:

    let x = 5i;

    let y: int = if x == 5i { 10i; } else { 15i; };

Обратите внимание на точки с запятыми после 10 и 15. Rust выдаст нам следующую ошибку:

    error: mismatched types: expected `int` but found `()` (expected int but found ())

Мы ожидали целое число, а получили `()`. `()` произносится как "блок", и это специальный тип в системе типов Rust'а. В Rust'е `()` это некорректное значение для переменной типа `int`. Это является допустимым значением только для переменных типа `()`, которые не очень полезны. Помните, как мы говорили, что операторы не возвращают значения? Это предназначение блока в таких случаях. Точка с запятой превращает любое выражение в оператор путем выбрасывания его значения и возвращения блока вместо этого.

Есть еще один случай, в котором вы не увидите точку с запятой в конце строки в коде Rust'a. Для этого нам понадобится следующее понятие: функции.

##6 Функции##
Вы уже видели одну функцию раньше, функция `main`:

    fn main() {
    }

Это наипростейший из возможных способов объявления функции. Как мы уже говорили ранее,`fn` говорит "это функция", затем ее имя, затем одинокие скобки, потому что функция не принимает параметров, затем фигурные скобки указывающие на тело функции. Это функция с названием `foo`:

    fn foo() {
    }

Так что на счет передачи параметров? Эта функция которая печатает число:

    fn print_number(x: int) {
        println!("x is: {}", x);
    }

Это полная программа, которая использует `print_number`:

    fn main() {
        print_number(5);
    }

    fn print_number(x: int) {
        println!("x is: {}", x);
    }

Как вы видите, параметры функции работают очень схоже с объявлением `let`: вы добавляете тип к имени параметра после двоеточия.

Это полная программа, которая складывает два числа и печатает результат:

    fn main() {
        print_sum(5, 6);
    }

    fn print_sum(x: int, y: int) {
        println!("sum is: {}", x + y);
    }

Вы разделяете параметры запятой, как при вызове функции, так и при ее объявлении.

В отличие от `let`, вы *должны* указывать типы параметров функции. Это не работает:

    fn print_number(x, y) {
        println!("x is: {}", x + y);
    }

Вы получите эту ошибку:

    hello.rs:5:18: 5:19 error: expected `:` but found `,`
    hello.rs:5 fn print_number(x, y) {

Это осознанное архитектурное решение. Пока вывод типа возможен, языки программирования которые поддерживают такую возможность, вроде Haskell, зачастую предполагают, что явное указание выших типов является хорошим тоном. Мы понимаем, что обязанность указывать тип функции пока возможен вывод типов в теле функции это золотая середина между полным выводом и отсутствием такового.

Что насчет возвращения значения? Это функция, которая добавляет единицу к целому числу:

    fn add_one(x: int) -> int {
        x + 1
    }

Функции Rust'a возвращают только одно значение, и вы объявляете тип после "стрелки", состоящей из тире (`-`) и знака больше (`>`). Вы должны были заметить отсутствующие здесь точку с запятой. Если мы их добавим сюда:

    fn add_one(x: int) -> int {
        x + 1;
    }

Мы получим ошибку:

    error: not all control paths return a value
    fn add_one(x: int) -> int {
         x + 1;
    }

    note: consider removing this semicolon:
         x + 1;
              ^

Помните нашу старую дисскуссию о точке запятой и `()`? Наша функция требует вернуть `int`, но изза точки c запятой вместо этого возвращается `()`. Rust понимает, что верятно это не то чего мы хотим, поэтому он предлагает удалить точку с запятой. 

Это очень похоже на наш предыдущий оператор `if`: результат блока (`{}`) это значение выражения. Другие выражение-ориентированные языки программирования, вроде Ruby, работают похоже, но они немного неприменимы в мире системного программирования. Когда люди впервые узнают об этом, они, как правило, предполагают, что это вступительные (? новичка? тутора? молодого языка программирования?) ошибки. Но поскольку система типов Rust'а так сильна, и поскольку блок его собственный уникальный тип, мы никогда не увидем, как удаление или возвращение точки с запятой станет причиной ошибки.

Но что на счет предварительного возврата? Rust имеет ключевое слово для этого - `return`:

    fn foo(x: int) -> int {
        if x < 5 { return x; }
    
        x + 1
    }

Использоваие `return` как последней строки функции будет работать, но это считается плохим тоном:

    fn foo(x: int) -> int {
        if x < 5 { return x; }
    
        return x + 1;
    }

Есть несколько дополнительных способов объявить функцию, но они включают в себя такие особенности, о которых мы пока не знаем, так что давайте оставим так как есть.


# 7 Комментарии #
Теперь, когда у нас есть несколько функций, неплохо бы узнать о комментариях. Комментарии это заметки, которые вы оставляете для других программистов, что бы помочь объяснить некоторые вещи в вашем коде. Компилятор в основном игнорирует их.

Rust имеет два вида комментариев, которые должны вас беспокоить: `строчные комментарии` и `doc-комментарии`.

    // Строчные комментарии это все что угодно после '//' и до конца строки.
    
    let x = 5i; // это тоже строчный комментарий.
    
    // Если у вас длинное объяснение для чего-либо, вы можете расположить строчные комментарии
    // один за другим. Поместите пробел между // и вашим комментарием, так как это более читаемо.

Другое применение комментария - это doc-комментарий. Doc-комментарий использует `///` вместо `//`, и поддерживает Markdown-разметку внутри:

    /// `hello` это функция которая выводит на экран персональное приветствие
    /// основанное на полученном имени
    ///
    /// # Параметры
    ///
    /// * `name` - Имя особы, которую вы хотите поприветствовать.
    /// 
    /// # Пример
    ///
    /// ```rust
    /// let name = "Steve";
    /// hello(name); // выведет "Hello, Steve!"
    /// ```
    fn hello(name: &str) {
        println!("Hello, {}!", name);
    }

При написании doc-комментария, добавление разделов для любых аргументов, возвращаемых значений, и приведение некоторых примеров использования очень и очень полезно.

Вы можете использовать инструмент `rustdoc` для генерации HTML-документации из этих doc-комментариев. Мы расскажем больше о `rustdoc` когда дойдем до модулей, в частности, вам понадобится экспортировать документацию для всего модуля.


























